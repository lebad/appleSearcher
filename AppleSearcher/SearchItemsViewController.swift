//
//  SearchItemsViewController.swift
//  AppleSearcher
//
//  Created by andrey on 31/01/16.
//  Copyright (c) 2016 AndreyLebedev. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so you can apply
//  clean architecture to your iOS avarMac projects, see http://clean-swift.com
//

import UIKit

protocol SearchItemsViewControllerInput
{
  func displayFetchedItems(viewModel: SearchItems_FetchItems_ViewModel)
}

protocol SearchItemsViewControllerOutput
{
  func fetchItems(request: SearchItems_FetchItems_Request)
}

class SearchItemsViewController: UIViewController, SearchItemsViewControllerInput
{
  var output: SearchItemsViewControllerOutput!
  var router: SearchItemsRouter!
  
  var displayedItems: [SearchItems_FetchItems_ViewModel.DisplayedItem] = []
  var cellHandlers: [NSIndexPath: ItemCellHandler] = [:]
  var itemImages: [Int: UIImage] = [:]
  
  let itemsInRequest = 20
  
  var didChangeText = false
  
  // MARK: Interface
  @IBOutlet weak var collectionView: UICollectionView! {
    didSet {
      let flowLayout = collectionView.collectionViewLayout as! UICollectionViewFlowLayout
      flowLayout.minimumLineSpacing = 5.0
      let nib = UINib(nibName: "ItemCollectionViewCell", bundle: nil)
      collectionView.registerNib(nib, forCellWithReuseIdentifier: "ItemCollectionViewCell")
    }
  }

  @IBOutlet weak var searchBar: UISearchBar! {
    didSet {
      searchBar.delegate = self;
    }
  }
  private var cellSizeCache = NSCache()
  
  // MARK: Object lifecycle
  
  override func awakeFromNib()
  {
    super.awakeFromNib()
    SearchItemsConfigurator.sharedInstance.configure(self)
  }
  
  // MARK: View lifecycle
  
  override func viewDidLoad() {
    super.viewDidLoad()
    
    collectionView.addGestureRecognizer(UITapGestureRecognizer(target: self, action: "tapWithGesture:"))
  }
  
  // MARK: Display logic
  
  func displayFetchedItems(viewModel: SearchItems_FetchItems_ViewModel) {
    
    if didChangeText == true {
      displayedItems = viewModel.displayedItems
      didChangeText = false
    } else {
      displayedItems += viewModel.displayedItems
    }
    
    var indexPaths = [NSIndexPath]()
    let index = displayedItems.count - viewModel.displayedItems.count
    
    for var i = index; i < displayedItems.count; i++ {
      indexPaths.append(NSIndexPath.init(forItem: i, inSection: 0))
    }
    collectionView.reloadData()
  }
  
  func request(searchString: String) -> SearchItems_FetchItems_Request {
    return SearchItems_FetchItems_Request(searchString: searchString,
      offset: displayedItems.count,
      itemsInRequest: self.itemsInRequest)
  }
  
  // MARK: Gestures
  
  func tapWithGesture(tapGestureRecognizer: UITapGestureRecognizer) {
    searchBar.resignFirstResponder()
  }
}

// MARK: UICollectionViewDelegateFlowLayout

extension SearchItemsViewController: UICollectionViewDelegateFlowLayout {
  func collectionView(collectionView: UICollectionView,
    layout collectionViewLayout: UICollectionViewLayout,
    sizeForItemAtIndexPath indexPath: NSIndexPath) -> CGSize {
    
      let displayedItem = displayedItems[indexPath.row]
      
      let cell = NSBundle.mainBundle().loadNibNamed("ItemCollectionViewCell",
        owner: self,
        options: nil).first as! ItemCollectionViewCell
      cell.width = CGRectGetWidth(collectionView.bounds)
      cell.updateCell(displayedItem)
      let cellSize = cell.calculateSize()
      return cellSize
  }
}

// MARK: UISearchBarDelegate

extension SearchItemsViewController: UISearchBarDelegate {
  
  func searchBar(searchBar: UISearchBar, textDidChange searchText: String) {
    didChangeText = true
    output.fetchItems(request(searchText))
  }
  
  func searchBarSearchButtonClicked(searchBar: UISearchBar) {
    searchBar.resignFirstResponder()
  }
}

//MARK: UICollectionViewDelegate

extension SearchItemsViewController: UICollectionViewDelegate {
  func collectionView(collectionView: UICollectionView,
    willDisplayCell cell: UICollectionViewCell,
    forItemAtIndexPath indexPath: NSIndexPath) {
      
      if indexPath.row == displayedItems.count - 6 {
        
        if let text = searchBar.text {
          output.fetchItems(request(text))
        }
      }
  }
}

//MARK: UICollectionViewDataSource

extension SearchItemsViewController: UICollectionViewDataSource {
  
  func numberOfSectionsInCollectionView(collectionView: UICollectionView) -> Int {
    return 1
  }
  
  func collectionView(collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
    return displayedItems.count
  }
  
  func collectionView(collectionView: UICollectionView,
    cellForItemAtIndexPath indexPath: NSIndexPath) -> UICollectionViewCell {
      
    let displayedItem = displayedItems[indexPath.row]
    let handler = getHandler(displayedItem, indexPath: indexPath)
    handler.delegate = self
    let cell = collectionView.dequeueReusableCellWithReuseIdentifier("ItemCollectionViewCell",
      forIndexPath: indexPath) as! ItemCollectionViewCell
    handler.updateDataFor(cell)
      
    return cell
  }
  
  func getHandler(displayedItem: SearchItems_FetchItems_ViewModel.DisplayedItem, indexPath: NSIndexPath) -> ItemCellHandler {
    if let handler: ItemCellHandler = cellHandlers[indexPath] {
      handler.updateDisplayedItem(displayedItem)
    } else {
      cellHandlers[indexPath] = ItemCellHandler(displayedItem: displayedItem, index: indexPath.row)
    }
    return cellHandlers[indexPath]!
  }
}

//MARK: ItemCellHandlerDelegate

extension SearchItemsViewController: ItemCellHandlerDelegate {
  
  func getImageAt(trackID id: Int) -> UIImage? {
    return itemImages[id]
  }
  
  func setImage(image: UIImage, atTrackID id: Int) {
    itemImages[id] =  image
  }
}










